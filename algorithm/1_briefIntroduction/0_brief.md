---
name: brief
sort: 0
---

[力扣](https://leetcode-cn.com/problemset/all/)

# 时间复杂度

```
并不是指运行的时间，而是算法执行语句的次数。我们可以通过计算时间复杂度，判断算法相对的执行时间

计算方法
①选取相对增长最高的项
②最高项系数是都化为1
③若是常数的话用O（1）表示

```

```
常见的时间复杂度有
常数阶O(1),
对数阶O(log2n),
线性阶O(n),
线性对数阶O(nlog2n),
平方阶O(n^2),
立方阶O(n^3),
k次方阶O(n^K),
指数阶O(2^n).
随着n的不断增大，时间复杂度不断增大，算法花费时间越多。

```

- O(1)

```
算法的执行时间不随着问题的规模n的增长而增长

    int x=1;
	while (x <10)
	{
		x++;
	}
```

- O(n^2)

```
当有若干循环语句,算法的时间复杂度是由嵌套层数最多的循环语句中最内层
语句的频度f(n)决定的

	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
		{
			;
		}
	}
```


# 空间复杂度

```
算法在运行过程中临时占用的存储空间大小的度量

①忽略常数，用O(1)表示
②递归算法的空间复杂度=递归深度N*每次递归所要的辅助空间
③对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的
空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程

```

- O(1)

```
int a;
int b;
int c;
printf("%d %d %d \n",a,b,c);

```

- O(n)

```
int fun(int n,)
{
int k=10;
if（n==k)
return n;
else
return fun(++n);
}
递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O（n*1）=O（n)

```
