---
name: go语言中的坑
sort: 10
---

## git加速

- channel的使用

```
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)
    ch <- 1
    fmt.Println(<-ch) // 1

}

package main

import (
    "fmt"
)

func main() {
    ch := make(chan int, 1)
    ch <- 1
    fmt.Println(<-ch) // 1

}

因为代码1的channel没有buffer，而代码2的channel设置了buffer为1。
没有buffer的channel只能通过另一个goroutine去读,否则就阻塞了。

可以理解成，代码1执行到 ch <- 1 时只有main一个“协程”（其实是线程），并没有其他协程进行接收 ch
-----------如果你使用某个包的channel,而你调用的时候,他还没有初始化buf,那么也会出现上述现象
```

- 锁的使用

lock与unlock之间一定注意没有 continue ,return,break,goto


- 函数指针入参

```
传入是指针,但是不能改变指针地址
package main

import (
	"fmt"
)

type foo struct {
	a int
}
func update1(f foo){
	f.a=2
}
func update2(f *foo) *foo{
	f.a=2
	var otherf foo
	otherf.a=3
	f=&otherf
	return &otherf
}
func main() {
	var f foo
	f.a=1
	update1(f)
	fmt.Println(f.a)
	otherf := update2(&f)
	fmt.Println(f.a)
	fmt.Println(otherf.a)
}

```